#### 一 隔离性与隔离级别

事务的四大特性ACID：

- Atomicity：原子性
- Consistency：一致性
- Isolation：隔离性
- Durability：持久性

SQL标准的事务隔离级别：

- read uncommitted（读未提交）:一个事务还未提交，它做的变更就能被别的事务看到。
- read committed（读提交）:一个事务提交后，它做的变更才会被别的事务看到。
- repeatable read（可重复读）:一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。同时未提交的变更对其它事务也是不可见的。
- serializable（串行化）:写会加写锁，读会加读锁。当出现锁冲突的时候，后访问到的事务必须等前一个事务执行完成，才能继续执行。

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“Repeatable Read”隔离级别下，这个视图是在事务启动的时候创建的，整个事务存在期间都用这个视图。

在“read committed”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。

使用

```sql
mysql> show variables like 'transaciton_isolation'; #8#
或者
mysql> show variables like 'tx_isolation';

#结果
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
1 row in set (0.00 sec)
```

查看隔离级别。

#### 二 事务隔离的实现

以“repeatable read”为例。在mysql中实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从1按顺序改成了2，3，4，在**undo log**（回滚日志）里面就会有类似下面的记录：

![20200621015057](../../media/20200621015057.png)

当前值是4，但是查询这条记录的时候，不同时刻启动的事务会有不同的read-view。同一条记录在系统中可以存在不同的版本，就是数据库的MVCC（多版本并发控制）。对于read-view A，要想得到1，就必须将当前值依次执行图中所有的回滚操作得到。

**undo log**什么时候删除？系统会判断，当没有事务再需要用到这些回滚日志的时候，回滚日志会删除。就是当系统中没有比回滚日志更早的read-view的时候。

基于上面的说明，应该避免使用长事务。长事务意味着会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能会用到的回滚记录都必须保留，这回导致大量占用存储空间。并且长事务还会占用锁资源。

#### 三 事务的启动方式

MySQL的事务启动方式有以下几种：

1. 显示启动事务语句，begin和start transaction。提交语句commit，回滚语句rollback；
2. set autocommit=0这个命令会将这个线程的自动提交关掉。需要主动commit或rollback。

建议使用set autocommit=1，通过显示的语句来启动事务。

#### 四 参考

- [MySQL 实战45讲 ]( https://time.geekbang.org/column/intro/100020801 )

