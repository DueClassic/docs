#### 一 .覆盖索引

如果执行的语句是：

```sql
select ID from T where k between 3 and 5;
```

这时只需要查ID的值，而ID的值已经在k索引树上了，索引可以直接提供查询结果，不需要回表。在这个查询中，索引k已经覆盖了我们的查询请求，我们称为覆盖索引。

**由于索引覆盖可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

Example：

> 在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？
>
> 如果现在有一个高频请求，要根据身份证号查询姓名，这个联合索引就变得非常有必要。它可以在这个高频请求上用到覆盖索引，不在需要回表查整行记录，减少语句的执行时间。当然，索引字段的维护也是有代价的。

#### 二. 最左前缀原则

在建立联合索引的时候，如何安排索引内的字段顺序？

 评估标准是：索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。接下来才考虑空间。

#### 三. 索引下推

在MySQL5.6之后引入了索引下推优化（index condition pushdown），可以减少索引遍历过程中，对索引中包括的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

Example：

> 以市民表的联合索引（name，age）为例。执行以下语句：
>
> ```sql
> mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
> ```
>
> 在MySQL5.6之前，查到姓名前缀为'张'的记录后，只能一个一个的回表，在对比字段值。
>
> 而存在索引下推优化后，InnoDB在（name，age）索引内部就判断了age是否等于10，对于不等于10的记录直接跳过，这样明显可以减少回表。

Q:

>现在有一个表，表结构定义如下：
>
>```sql
>create table `geek`(
>`a` int (11) not null,
>`b` int (11) not null,
>`c` int (11) not null,
>`d` int (11) not null,
>primary key(`a`,`b`),
>key `c` (`c`) ,
>key `ca` (`c`,`a`),
>key `cb` (`c`,`b`)
>)engine=InnoDB;
>```
>
>由于历史原因，这个表需要a,b做联合主键。
>
>且业务中有以下查询语句：
>
>```sql
>select * from geek where c=N order by a limit 1;
>select * from geek where c=N order by b limit 1;
>```
>
>请问为了这两个查询语句，“ca”，“cb”这两个索引是否都必须存在？

A:

>主键a,b的聚簇索引组织顺序相当于order by a,b，也就是先按a排序，再按b排序，c无序。
>
>```sql
>(a,b)
>-a--|-b--|-c--|-d--
>```
>
>索引c,a的组织是先按c排序，再按a排序，同时记录主键；这个跟索引c的数据是一模一样的。
>
>```sql
>(c,a)
>-c--|-a--|-b--
>
>(c)
>-c--|-a--|-b--
>```
>
>索引c,b的组织是先按c排序，再按b排序，同时记录主键
>
>```sql
>(c,b)
>-c--|-b--|-a--
>```
>
>结论是ca可以去掉，cb需要保留。

#### 四 参考

- [MySQL 实战45讲 ]( https://time.geekbang.org/column/intro/100020801 )

